# Architecture

`ysr` is build on top of [LMDB](https://www.symas.com/mdb) - a persistent key value store database. Its goal is to
support a [yjs](https://github.com/yjs/yjs/) Conflict-free Replicated Data Types library on top of
disk-native architecture. It aims to achieve several goals:

- Binary compatibility with `yjs` update format: any update generated by `yjs` should be applicable to `ysr` document
  and produce an equivalent structure.
- Behavior compatibility with `yjs`: at its current state `ysr` aims to offer a subset of `yjs` types collectively
  represented as a `Node` (in `yjs` refered to a `YType`), offering capabilities of types such as map, array and rich
  text. These structures should produce the same output as their equivalents on `yjs`.
- Disk-native format: one of the problems of `yjs` was potential size of the in-memory documents and complex path to
  high performance persistence. `ysr` is build with disk-native in mind, meaning all of its data structures are mapped
  directly to a persistent memory and read from it in an efficient manner with support of mmap (realized via LMDB
  interface). Unlike `yjs`, `ysr` doesn't need to decode an entire document state before reading it. Instead, it can
  just read fragments of data required to serve user requests.
- Zero-copy serialization: thanks to [zerocopy](https://docs.rs/zerocopy/0.8.39/zerocopy/) crate, we can map required
  structures layout directly onto memory without any need to copy it around. This matters mostly for `ysr` specific
  metadata, as user data can be of any shape and its stored using [lib0](../src/lib0) encoding.

## MultiDoc

Each LMDB environment is capable of hosting multiple LMDB databases. We elevate that approach to enable users
to store multiple `ysr` documents within a single LMDB store file. A `MultiDoc` is a structure responsible for holding
an LMDB environment and therefore managing overall on-disk data access.

Each `ysr` document is mapped onto its own dedicated LMDB database handle. Whenever a user needs to access a particular
document, it can be done by creating a transaction using that document's unique `guid` string as a database name. From
there a database handle, and its referencing LMDB transaction are both served as part of a LMDB `Database<'tx>` struct,
that our `ysr::Transaction` manages. This transaction can be used to make a further `ysr` document operations.

## Stores

`ysr` architecture places each of the core units of work in their dedicated key-spaces within LMDB database. These
key-spaces are separated from each other by their leading byte, used as a prefix for all key-value entries within that
key-space range.

There are several different key-spaces (further on referenced to as a *stores*):

- [InternStringsStore](stores/01_intern_strings_store.md)
- [MetaStore](stores/00_meta_store.md) is responsible for holding documents unique metadata such as current client ID
  and
  document's options.
- [StateVectorStore](stores/05_state_vector_store.md), which is responsible for holding `ClientID`->`Clock` key value
  pairs
  representing current state of integrated document data.
- [BlockStore](stores/02_block_store.md) representing blocks - pieces of metadata used by `ysr` and `yjs` for conflict
  resolution.
- [ContentStore](stores/03_content_data.md) representing user data, related to blocks. It only holds data that was too
  big to be inlined within block store headers themselves.
- [MapEntryStore](stores/04_map_entries.md) holding information about `(NodeID, String)`->`ID` key-value entries
  representing the relationships
  between YMap user-defined keys and the IDs of the blocks holding the data for those entries.

## Nodes

`Node` - referred to in `yjs` as [YType](https://github.com/yjs/yjs/blob/main/src/ytype.js) - represents an universal
collaborative editing collection. You can read about them more at [here](./nodes.md).

## Serialization

In some cases `ysr` (just like `yjs`) use JSON encoding for user-defined objects. In `ysr` this serialization is
achieved through use of [serde_json](https://docs.rs/serde_json/1.0.149/serde_json/) crate. However, for most part `ysr`
and `yjs` both use custom serialization format called `lib0`. `ysr::lib0` module implements `serde` traits and
is capable of producing `lib0`-compatible binary format.

`ysr::lib0` API is similar to `serde_json`, however as a binary format it doesn't target string related functions.

`ysr::lib0` additionally offers `copy` method which allows to copy `lib0`-encoded objects from reader to writer, one
object at the time, by the means of byte copying, without the need to deserialize/serialize objects from reader to
writer.